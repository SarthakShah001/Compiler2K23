<program> -> <moduleDeclarations><otherModules><driverModule><otherModules>                     
<moduleDeclarations> -> <moduleDeclaration><moduleDeclarations> | ε
<moduleDeclaration> -> TK_DECLARE TK_MODULE TK_ID TK_SEMICOL
<otherModules> -> <module><otherModules>| ε
<driverModule> -> DRIVERDEF DRIVER PROGRAM DRIVERENDDEF <moduleDef>
<module> -> DEF MODULE ID ENDDEF TAKES INPUT SQBO <input_plist> SQBC SEMICOL <ret><moduleDef>
<ret> -> RETURNS SQBO <output_plist> SQBC SEMICOL | ε
<input_plist> -> ID COLON <dataType><N1>
<N1> -> COMMA ID COLON <dataType> <N1> | ε
<output_plist> -> ID COLON <type> <N2> 
<N2> -> COMMA ID COLON <type><N2> | ε 
<dataType> -> ARRAY SQBO <range_arrays> SQBC OF <type>
<range_arrays> -> <index_arr> RANGEOP <index_arr> 
<type> -> INTEGER | REAL | BOOLEAN
<moduleDef> -> START <statements> END
<statements> -> <statement> <statements> | ε
<statement> -> <ioStmt>|<simpleStmt>|<declareStmt>|<condionalStmt>|<iterativeStmt>
<ioStmt>-> GET_VALUE BO ID BC SEMICOL | PRINT BO <var_print> BC SEMICOL
<boolConstt> -> TRUE | FALSE
<id_num_rnum> -> ID | NUM | RNUM
<array_element_for_print> -> ID SQBO <new_index> SQBC
<var_print> -> < id_num_rnum> | <boolConstt> | <array_element_for_print>
<var_print> -> ID <P1> | NUM | RNUM | <boolConstt>
<P1> -> SQBO <new_index> SQBC | ε
<simpleStmt> -> <assignmentStmt> | <moduleReuseStmt>
<assignmentStmt> -> ID <whichStmt>
<whichStmt> -> <lvalueIDStmt> | <lvalueARRStmt>
<lvalueIDStmt> -> ASSIGNOP <expression> SEMICOL
<lvalueARRStmt> -> SQBO <element_index_with_expressions> SQBC ASSIGNOP <expression> SEMICOL 
<index_arr> -> <sign><new_index>
<new_index> -> NUM | ID
<sign> -> PLUS | MINUS | ε
<moduleReuseStmt> -> <optional> USE MODULE ID WITH PARAMETERS <idList>SEMICOL
<optional> -> SQBO <idList> SQBC ASSIGNOP | ε
<output_plist> -> ID <N3>
<N3> -> COMMA ID <N3> | ε
<expression> -> <arithmeticOrBooleanExpr> | <U> 
<new_NT> -> BO <arithmeticExpr> BC | <var_id_num> 
<unary_op> -> PLUS | MINUS
<arithmeticExpr> -> <arithmeticExpr> <op> <term>
<arithmeticExpr> -> <term> <N4> 
<N4> -> <op1> <term> <N4> | ε
<term> -> <term> <op> <factor>
<term> -> <factor> <N5> 
<N5> -> <op2> <factor> <N5>| ε 
<factor> -> BO <arithmeticExpr> BC
<factor> -> <id_num_rnum> | <boolConstt> | <array_element>
<array_element> -> ID SQBO <element_index_with_expressions> SQBC
<element_index_with_expressions> -> <sign> <new_index> | <arrExpr> | <sign> BO <arrExpr> BC
<arrExpr> -> <arrTerm> <arr_N4>
<arr_N4> -> <op1> <arrTerm> <arr_N4> | ε
<arrTerm> -> <arrFactor> <arr_N5> 
<arr_N5> -> <op2> <arrFactor> <arr_N5>| ε 
<arrFactor> -> <id_num_rnum> | <boolConstt> | BO <arrExpr> BC
<element_index_with_expressions> -> <sign> <N_10> | <arrExpr> …..33 i
<N_10> -> <new_index> | BO <arrExpr> BC 
<op1> -> PLUS|MINUS
<op2> -> MUL|DIV 
<logicalOp> -> AND | OR
<relationalOp> -> LT | LE | GT | GE | EQ | NE
<declareStmt> -> DECLARE <idList> COLON <dataType> SEMICOL
<condionalStmt> -> SWITCH BO ID BC START <caseStmts><default> END 
<caseStmts> -> CASE <value> COLON <statements> BREAK SEMICOL <N9>
<N9> -> CASE <value> COLON <statements> BREAK SEMICOL <N9> | ε
<value> -> NUM | TRUE | FALSE
<default> -> DEFAULT COLON <statements> BREAK SEMICOL | ε
<iterativeStmt> -> FOR BO ID IN <range_for_loop> BC START <statements> END |
<iterativeStmt> -> WHILE BO <arithmeticOrBooleanExpr> BC START <statements> END
<index_for_loop> -> <sign_for_loop><new_index_for_loop> 
<new_index_for_loop > -> NUM 
<sign_for_loop > -> PLUS | MINUS | ε

<program> -> <moduleDeclarations><otherModules><driverModule><otherModules>
<moduleDeclarations> -> <moduleDeclaration><moduleDeclarations>
<moduleDeclarations> -> ε
<moduleDeclaration> -> TK_DECLARE TK_MODULE TK_ID TK_SEMICOL
<otherModules> -> <module><otherModules> 
<otherModules> -> ε
<driverModule> -> TK_DRIVERDEF TK_DRIVER TK_PROGRAM TK_DRIVERENDDEF <moduleDef>
<module> -> TK_DEF TK_MODULE TK_ID TK_ENDDEF TK_TAKES TK_INPUT TK_SQBO <input_plist> TK_SQBC TK_SEMICOL <ret><moduleDef>
<ret> -> TK_RETURNS TK_SQBO <output_plist> TK_SQBC TK_SEMICOL 
<ret> -> ε
<input_plist> -> TK_ID TK_COLON <dataType><N1>
<N1> -> TK_COMMA TK_ID TK_COLON <dataType><N1>
<N1> -> ε
<output_plist> -> TK_ID TK_COLON <type><N2>
<N2> -> TK_COMMA TK_ID TK_COLON <type><N2>
<N2> -> ε
<dataType> -> TK_ARRAY TK_SQBO <range_arrays> TK_SQBC TK_OF <type>
<range_arrays> -> <index_arr> RANGEOP <index_arr> 
<type> -> INTEGER 
<type> -> REAL 
<type> -> BOOLEAN
<moduleDef> -> START <statements> END
<statements> -> <statement><statements> 
<statements> -> ε
<statement> -> <ioStmt>
<statement> -> <simpleStmt>
<statement> -> <declareStmt>
<statement> -> <condionalStmt>
<statement> -> <iterativeStmt>
<ioStmt>-> GET_VALUE BO ID BC SEMICOL 
<ioStmt>-> PRINT BO <var_print> BC SEMICOL
<boolConstt> -> TRUE 
<boolConstt> -> FALSE
<id_num_rnum> -> ID 
<id_num_rnum> -> NUM 
<id_num_rnum> -> RNUM
<array_element_for_print> -> ID SQBO <new_index> SQBC
<var_print> -> < id_num_rnum> 
<var_print> -> <boolConstt> 
<var_print> -> <array_element_for_print>
<var_print> -> ID <P1> 
<var_print> -> NUM 
<var_print> -> RNUM 
<var_print> -> <boolConstt>
<P1> -> SQBO <new_index> SQBC 
<P1> -> ε
<simpleStmt> -> <assignmentStmt> 
<simpleStmt> -> <moduleReuseStmt>
<assignmentStmt> -> ID <whichStmt>
<whichStmt> -> <lvalueIDStmt> 
<whichStmt> -> <lvalueARRStmt>
<lvalueIDStmt> -> ASSIGNOP <expression> SEMICOL
<lvalueARRStmt> -> SQBO <element_index_with_expressions> SQBC ASSIGNOP <expression> SEMICOL 
<index_arr> -> <sign><new_index>
<new_index> -> NUM 
<new_index> ID
<sign> -> PLUS 
<sign> -> MINUS 
<sign> -> ε
<moduleReuseStmt> -> <optional> USE MODULE ID WITH PARAMETERS <idList>SEMICOL
<optional> -> SQBO <idList> SQBC ASSIGNOP 
<optional> -> ε
<output_plist> -> ID <N3>
<N3> -> COMMA ID <N3> 
<N3> -> ε
<expression> -> <arithmeticOrBooleanExpr> 
<expression> -> <U> 
<new_NT> -> BO <arithmeticExpr> BC 
<new_NT> -> <var_id_num> 
<unary_op> -> PLUS 
<unary_op> -> MINUS
<arithmeticExpr> -> <arithmeticExpr> <op> <term>
<arithmeticExpr> -> <term> <N4> 
<N4> -> <op1> <term> <N4> 
| ε
<term> -> <term> <op> <factor>
<term> -> <factor> <N5> 
<N5> -> <op2> <factor> <N5>
| ε 
<factor> -> BO <arithmeticExpr> BC
<factor> -> <id_num_rnum> 
| <boolConstt> 
| <array_element>
<array_element> -> ID SQBO <element_index_with_expressions> SQBC
<element_index_with_expressions> -> <sign> <new_index> 
| <arrExpr> 
| <sign> BO <arrExpr> BC
<arrExpr> -> <arrTerm> <arr_N4>
<arr_N4> -> <op1> <arrTerm> <arr_N4> 
| ε
<arrTerm> -> <arrFactor> <arr_N5> 
<arr_N5> -> <op2> <arrFactor> <arr_N5>
| ε 
<arrFactor> -> <id_num_rnum> 
| <boolConstt> 
| BO <arrExpr> BC
<element_index_with_expressions> -> <sign> <N_10> 
| <arrExpr> …..33 i
<N_10> -> <new_index> 
| BO <arrExpr> BC 
<op1> -> PLUS
|MINUS
<op2> -> MUL
|DIV 
<logicalOp> -> AND 
| OR
<relationalOp> -> LT 
| LE 
| GT 
| GE 
| EQ 
| NE
<declareStmt> -> DECLARE <idList> COLON <dataType> SEMICOL
<condionalStmt> -> SWITCH BO ID BC START <caseStmts><default> END 
<caseStmts> -> CASE <value> COLON <statements> BREAK SEMICOL <N9>
<N9> -> CASE <value> COLON <statements> BREAK SEMICOL <N9> | ε
<value> -> NUM 
| TRUE 
| FALSE
<default> -> DEFAULT COLON <statements> BREAK SEMICOL 
| ε
<iterativeStmt> -> FOR BO ID IN <range_for_loop> BC START <statements> END
<iterativeStmt> -> WHILE BO <arithmeticOrBooleanExpr> BC START <statements> END
<index_for_loop> -> <sign_for_loop><new_index_for_loop> 
<new_index_for_loop > -> NUM 
<sign_for_loop > -> PLUS 
| MINUS 
| ε
